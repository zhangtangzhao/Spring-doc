<html>
<head>
  <title>Spring基础</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/606400 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="599"/>
<h1>Spring基础</h1>

<div>
<span><div><div><div><span style="font-weight: bold;">Spring启动上下文核心方法：</span></div><div style="box-sizing: border-box; background-color: rgb(248, 248, 248); margin-bottom: 16px;"><div style="box-sizing: border-box; font-size: 12px; margin-top: 0px; margin-bottom: 0px; background-color: rgb(246, 248, 250); overflow-wrap: normal; padding: 16px; overflow: auto; border-radius: 6px; border: 1px solid rgb(225, 228, 232); word-break: normal;"><span style="background-color: rgb(255, 255, 255); font-size: 16px;"><span style="box-sizing: border-box; font-size: 12px; overflow-wrap: normal; overflow: visible; border-radius: 6px; border: 0px; word-break: normal; background: transparent; white-space: pre; color: rgb(60, 69, 78); font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, monospace; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.45;">AbstractApplicationContext.refresh()</span></span></div></div><div><span style="font-weight: bold;">IOC</span>：inverse if control （控制反转），将一个对象的创建、销毁交给spring容器控制</div><div>主要作用：解耦</div><div><br/></div><div><span style="font-weight: bold;">Spring Bean的基本属性详解</span></div><ol style="box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 16px; font-size: 16px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><li style="box-sizing: border-box;"><div><span style="font-size: 16px; color: rgb(60, 69, 78); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">id: Bean的唯一标识名。</span></div></li><li style="box-sizing: border-box; margin-top: 0.25em;"><div><span style="font-size: 16px; color: rgb(60, 69, 78); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">name: 用来为id创建一个或多个别名。多个别名之间用逗号或空格分开</span></div></li><li style="box-sizing: border-box; margin-top: 0.25em;"><div><span style="font-size: 16px; color: rgb(60, 69, 78); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">class：用来定义类的全限定名。只有子类Bean不用定义该属性</span></div></li><li style="box-sizing: border-box; margin-top: 0.25em;"><div><span style="font-size: 16px; color: rgb(60, 69, 78); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">parent: 子类Bean定义它所引用它的父类Bean。这时前面的class属性失效。子类Bean会继承父类Bean的所有属性，子类Bean也可以覆盖父类Bean的属性。注意：子类Bean和父类Bean是用一个java类</span></div></li><li style="box-sizing: border-box; margin-top: 0.25em;"><div><span style="font-size: 16px; color: rgb(60, 69, 78); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">abstracct(默认为false)：用来定义Bean是否为抽象Bean. 它表示这个Bean将不会被实例化，一般用于父类Bean，因为父类Bean主要是供子类Bean继承使用</span></div></li><li style="box-sizing: border-box; margin-top: 0.25em;"><div><span style="font-size: 16px; color: rgb(60, 69, 78); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">lazy-init(默认为default)：用来定义这个Bean是否实现懒初始化。如果为true，它将在BeanFactory启动时初始化所有的SingletonBean。反之，只在Bean请求时才开始创建SingletonBean</span></div></li><li style="box-sizing: border-box; margin-top: 0.25em;"><div><span style="font-size: 16px; color: rgb(60, 69, 78); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">autowire(自动装配，默认为default): 它定义了Bean的自动装载方式 1、&quot;no&quot; ： 不使用自动装配功能 2、&quot;byName&quot;：通过Bean的属性名实现自动装配 3、&quot;byType&quot;：通过Bean的类型实现自动装配 4、&quot;constructor&quot;: 类似于byType，但它是用于构造函数的参数的额自动组装 5、&quot;autodetect&quot;: 通过Bean类的反省机制(introspection)决定是使用&quot;constructor&quot;还是使用&quot;byType&quot;</span></div></li><li style="box-sizing: border-box; margin-top: 0.25em;"><div><span style="font-size: 16px; color: rgb(60, 69, 78); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">depends-on(依赖对象): 这个Bean在初始化时依赖的对象，这个对象会在这个Bean初始化之前创建</span></div></li><li style="box-sizing: border-box; margin-top: 0.25em;"><div><span style="font-size: 16px; color: rgb(60, 69, 78); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">init-method：用来定义Bean的初始化方法，它会在Bean组装之后调用。它必须是一个无参数的方法</span></div></li><li style="box-sizing: border-box; margin-top: 0.25em;"><div><span style="font-size: 16px; color: rgb(60, 69, 78); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">destroy-method:用来定义Bean的销毁方法，它在BeanFactory关闭时调用。它必须是一个无参的方法。只能应用于singletonBean</span></div></li><li style="box-sizing: border-box; margin-top: 0.25em;"><div><span style="font-size: 16px; color: rgb(60, 69, 78); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">factory-method：定义创建该Bean对象的工厂方法。用于下面的&quot;factory-bean&quot;，表示这个Bean是通过工厂方法创建。此时,class属性失效</span></div></li><li style="box-sizing: border-box; margin-top: 0.25em;"><div><span style="font-size: 16px; color: rgb(60, 69, 78); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">factor-bean: 定义创建该Bean对象的工厂类。如果使用了factory-bean 则class属性失效</span></div></li><li style="box-sizing: border-box; margin-top: 0.25em;"><div><span style="font-size: 16px; color: rgb(60, 69, 78); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">MutablePropertyValues：用于封装</span></div></li><li style="box-sizing: border-box; margin-top: 0.25em;"><div><span style="font-size: 16px; color: rgb(60, 69, 78); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">ConstructorArgumentValues：用于封装标签的 信息，其实类里面就是有一个map，map中用构造函数的参数顺序作为Key,值作为value存储到map中</span></div></li><li style="box-sizing: border-box; margin-top: 0.25em;"><div><span style="font-size: 16px; color: rgb(60, 69, 78); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">MethodOverrides:用于封装lookup-method和replaced-method标签的信息，同样的类里面有一个set对象添加LookupOverride对象和ReplaceOverride对象</span></div></li></ol><div><br/></div><div><span style="font-weight: bold;">Spring解析xml文件过程</span></div><ol style="box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 16px; font-size: 16px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><li style="box-sizing: border-box;"><div><span style="font-size: 16px; color: rgb(60, 69, 78); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">通过XmlBeanDefinitionReader.doLoadBeanDefinitions()利用jdk sax解析xml里面的每个元素封装到BeanDefinition对象 详细解析bean标签—–&gt; BeanDefinitionParserDelegate.parseBeanDefinitionElement()</span></div></li><li style="box-sizing: border-box; margin-top: 0.25em;"><div><span style="font-size: 16px; color: rgb(60, 69, 78); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">标签 ---&gt; 对应spring.handlers文件中ContextNamespaceHandler</span></div></li><li style="box-sizing: border-box; margin-top: 0.25em;"><div><span style="font-size: 16px; color: rgb(60, 69, 78); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">自定义标签的解析逻辑：根据当前解析标签的头信息找到对应的namespaceUri，加载spring所有Jar包的spring.handlers文件并建立映射关系，根据namespaceUri从映射关系中找到对应的实现了NamespaceHandler接口的类，调用类的Init方法（注册了各种自定义标签的解析类），根据namespaceUri找到对应的解析类，然后调用Paser方法完成标签解析</span></div></li><li style="box-sizing: border-box; margin-top: 0.25em;"><div><span style="font-size: 16px; color: rgb(60, 69, 78); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">自定义标签的扫描过程：doScanner方法 去扫描基本包的路径下面找class文件，递归找class文件，判断class文件里面是否有includeFilter里面的注解(</span><a href="https://github.com/Component" style="box-sizing: border-box; font-size: 16px; color: rgb(3, 102, 214); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">@Component</a><span style="font-size: 16px; color: rgb(60, 69, 78); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">),封装成BeanDefinition对象</span></div></li></ol><div style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px; font-size: 16px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="box-sizing: border-box; font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(60, 69, 78); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">AbstractApplicationContext.invokeBeanFactoryPostProcessors方法调用下面的接口 BeanDefinitionRegistryPostProcessor 在bean的实例化之前调用，可以完成BeanDefinition的操作</span></div><ol style="box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 16px; font-size: 16px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><li style="box-sizing: border-box;"><div><span style="font-size: 16px; color: rgb(60, 69, 78); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">postProcessBeanDefinitionRegistry 获取注册器参数</span></div></li><li style="box-sizing: border-box; margin-top: 0.25em;"><div><span style="font-size: 16px; color: rgb(60, 69, 78); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">postProcessBeanFactory 获取容器工厂参数</span></div></li></ol><div style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px; font-size: 16px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="box-sizing: border-box; font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(60, 69, 78); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">自定义扫描类 实现ClassPathBeanDefinitionScanner接口</span></div><div style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px; font-size: 16px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="box-sizing: border-box; font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(60, 69, 78); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">BeanPostProcessors的接口实现类在ComponentScanBeanDefinitionParser.registerComponents（注册组件） AbstractApplicationContext.registerBeanPostprocessors 然后在PostProcessorRegistrationDelegate.registerBeanPostprocessors拿到所有实现了BeanPostProcessors接口的类</span></div><div style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px; font-size: 16px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="box-sizing: border-box; font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Bean的生命周期</span></div><div style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px; font-size: 16px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 12pt;"><img src="Spring基础_files/Image.png" type="image/png" data-filename="Image.png"/></span><br/></div><div style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px; font-size: 16px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="box-sizing: border-box; font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px; font-size: 16px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="box-sizing: border-box; font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 16px; color: rgb(60, 69, 78); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">Spring 创建Bean的过程</span></span></div><div style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px; font-size: 16px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"></div><ol style="box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 16px; font-size: 16px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><li style="box-sizing: border-box;"><div><span style="font-size: 16px; color: rgb(60, 69, 78); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">AbstractAutowireCapableBeanFactory.createBeanInstance() 实例化factoryMethod方法对应的实例，实例化带有</span><a href="https://github.com/Autowired" style="box-sizing: border-box; font-size: 16px; color: rgb(3, 102, 214); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">@Autowired</a><span style="font-size: 16px; color: rgb(60, 69, 78); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">的有参构造函数，实例化带有</span><a href="https://github.com/Autowired" style="box-sizing: border-box; font-size: 16px; color: rgb(3, 102, 214); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">@Autowired</a><span style="font-size: 16px; color: rgb(60, 69, 78); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">的无参构造函数，实例化无参构造函数 getFactoryMethodName —-&gt; 定义了factory-method的属性， 定义和</span><a href="https://github.com/Bean" style="box-sizing: border-box; font-size: 16px; color: rgb(3, 102, 214); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">@Bean</a></div></li></ol><div style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px; font-size: 16px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><a href="https://github.com/Autowited" style="box-sizing: border-box; font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(3, 102, 214); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">@Autowited</a><span style="box-sizing: border-box; font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(60, 69, 78); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">注解的方法或者属性都会触发getBean操作</span></div><div style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px; font-size: 16px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="box-sizing: border-box; font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(60, 69, 78); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">多个</span><a href="https://github.com/Autowired" style="box-sizing: border-box; font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(3, 102, 214); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">@Autowired</a><span style="box-sizing: border-box; font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(60, 69, 78); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">注解的有参构造函数，会根据构造函数的参数个数进行降序</span></div><div style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px; font-size: 16px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="box-sizing: border-box; font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(60, 69, 78); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">多个没有</span><a href="https://github.com/Autowired" style="box-sizing: border-box; font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(3, 102, 214); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">@Autowired</a><span style="box-sizing: border-box; font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(60, 69, 78); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">注解的构造函数，只会调用默认的构造函数，利用的jdk的实例化</span></div><div style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px; font-size: 16px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="background-color: rgb(255, 255, 255); font-size: 16px;"><span style="box-sizing: border-box; font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(60, 69, 78); font-family: Lato, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">实现SmartInstantiationAwareBeanPostProcess，然后重写getEarlyBeanReference方法，可以对bean的对象进行修改或者操作</span></span></div></div><div><img src="Spring基础_files/Spring.jpg" type="image/jpeg" data-filename="Spring.jpg"/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">AOP</span></div><div>面向切面编程，是通过运行期动态代理，实现程序功能统一维护的技术。可以对业务逻辑进行隔离，从而使业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提交开发效率</div><div>AOP的用途：记录日志，性能监控，事务管理，权限控制，编写插件</div><div><br/></div><div><span style="font-weight: bold;">创建代理对象有两种</span>：</div><div><span style="font-weight: bold;">   基于接口的动态代理</span></div><ul><li><div>提供者：JDK</div></li><li><div>使用JDK官方的Proxy类创建对象</div></li><li><div>代理目标需要实现接口</div></li></ul><div><span style="font-weight: bold;">  基于类的动态代理</span></div><ul><li><div>提供者：CGLib</div></li><li><div>使用cglib的Enhancer类创建代理对象</div></li><li><div>需要导入asm.jar包</div></li></ul><div><br/></div><div>AOP的基础概念</div><ul><li><div>Pointcut(切入点)：需要增强的功能方法就是切入点</div></li><li><div>Aspect(切面)：切面由切点和增强组成</div></li><li><div>JoinPoint(连接点)：某个功能或者方法执行前后的位置</div></li><li><div>Target(目标对象)：需要增强的目标类</div></li><li><div>Weaving(织入)：将增强的逻辑添加到目标类的具体连接点的过程</div></li><li><div>Proxy(代理)：一个类被AO增强后，会产生一个代理对象，融合了原类和增强逻辑的代理类</div></li><li><div>Advice(通知/增强)：增强你的逻辑代码</div></li></ul><div><br/></div><div>四种通知/增强类型：</div><div>前置通知(before)：用于配置前置通知。指定增强的方法在切入点方法之前执行</div><ul><li><div>执行时间点：切入点方法执行之前执行</div></li><li><div>method:用于指定通知类中的增强方法名称</div></li><li><div>ponitcut-ref：用于指定切入点的表达式的引用</div></li><li><div>poinitcut：用于指定切入点表达式</div></li></ul><div>后置通知(afterReturn)：用于配置后置通知。指定增强的方法在切入点方法之后执行 </div><ul><li><div>执行时间点：切入点方法正常执行之后。抛出异常就不执行了</div></li><li><div>method:用于指定通知类中的增强方法名称</div></li><li><div>ponitcut-ref：用于指定切入点的表达式的引用</div></li><li><div>poinitcut：用于指定切入点表达式</div></li></ul><div>异常通知(afterThrowing)：用于配置异常通知，方法抛出异常执行</div><ul><li><div> 执行时间点：切入点方法执行产生异常后执行。它和后置通知只能执行一个</div></li><li><div>method:用于指定通知类中的增强方法名称</div></li><li><div>ponitcut-ref：用于指定切入点的表达式的引用</div></li><li><div>poinitcut：用于指定切入点表达式</div></li></ul><div>最终通知(after)：用于配置最终通知，在方法执行完毕的最后执行 </div><ul><li><div>执行时间点：无论切入点方法执行时是否有异常，它都会在其后面执行</div></li><li><div>method:用于指定通知类中的增强方法名称</div></li><li><div>ponitcut-ref：用于指定切入点的表达式的引用</div></li><li><div>poinitcut：用于指定切入点表达式</div></li></ul><div>环绕通知(around) 用于配置环绕通知。它是 spring 框架为我们提供的一种可以在代码中手动控制增强代码什么时候执行的 方式。</div><ul><li><div> method:用于指定通知类中的增强方法名称</div></li><li><div>ponitcut-ref：用于指定切入点的表达式的引用</div></li><li><div>poinitcut：用于指定切入点表达式</div></li><li><div>注意：通常情况下，环绕通知都是独立使用的</div></li></ul><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</div><div>xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div>xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</div><div>xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</div><div>http://www.springframework.org/schema/beans/spring-beans.xsd</div><div>http://www.springframework.org/schema/aop</div><div>http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</div><div>        &lt;!--配置业务层实现类--&gt;</div><div>        &lt;bean id=&quot;accountService&quot; class=&quot;com.hero.service.AccountServiceImpl&quot;/&gt;</div><div>        &lt;!--配置日志通知(增强)工具对象，交由Spring ioc容器管理--&gt;</div><div>        &lt;bean id=&quot;logger&quot; class=&quot;com.hero.utils.LogUtils&quot;/&gt;</div><div>        &lt;!-- 配置AOP --&gt;</div><div>        &lt;aop:config&gt;</div><div>            &lt;!-- 配置切面：id属性：设置当前切面的唯一标识、ref属性：指定当前切面的增强类(日志增强工具类) --&gt;</div><div>            &lt;aop:aspect id=&quot;loggerAdvice&quot; ref=&quot;logger&quot;&gt;</div><div>                &lt;!-- 配置切入点 --&gt;</div><div>                &lt;aop:pointcut id=&quot;logPointcut&quot; expression=&quot;execution(public * com.hello.*.AccountServiceImpl.*(..))&quot;/&gt;</div><div>                &lt;!-- 配置前置增强：在方法执行前执行--&gt;</div><div>                &lt;aop:before method=&quot;beforePrintLog&quot; pointcut-ref=&quot;logPointcut&quot;/&gt;</div><div>                &lt;!-- 配置配置后置通知：在方法执行完毕之后执行(即便抛出异常还是执行) --&gt;</div><div>                &lt;aop:after-returning method=&quot;afterReturnPrintLog&quot; pointcutref=&quot;logPointcut&quot;/&gt;</div><div>                &lt;!-- 配置异常通知增强：在方法抛出异常后执行 --&gt;</div><div>                &lt;aop:after-throwing method=&quot;afterThrowingPrintLog&quot; pointcutref=&quot;logPointcut&quot;/&gt;</div><div>                &lt;!-- 配置最终通知增强：在方法执行后执行 --&gt;</div><div>                &lt;aop:after method=&quot;afterPrintLog&quot; pointcut-ref=&quot;logPointcut&quot;/&gt;</div><div>                &lt;!--配置环绕通知：一个顶四个--&gt;</div><div>                &lt;aop:around method=&quot;aroundPrintLog&quot; pointcut-ref=&quot;logPointcut&quot;/&gt;</div><div>            &lt;/aop:aspect&gt;</div><div>        &lt;/aop:config&gt;</div><div>&lt;/beans&gt;</div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/** * 日志根据类，业务逻辑中的横切逻辑(通知，增强，) */ </div><div>public class LogUtils { </div><div>    //方法之前输出日志 </div><div>    public void beforePrintLog(){ </div><div>        System.out.println(&quot;在方法之前执行&quot;);</div><div>     } </div><div>    //方法之后输出日志 </div><div>    public void afterReturnPrintLog(){ </div><div>        System.out.println(&quot;在方法之后执行，有异常就不执行&quot;); </div><div>    } </div><div>    //方法抛出异常执行 </div><div>    public void afterThrowingPrintLog(){</div><div>        System.out.println(&quot;在方法抛出异常之后执行&quot;); </div><div>    } </div><div>    //方法的最后执行，不论有没有异常 </div><div>    public void afterPrintLog(){ </div><div>        System.out.println(&quot;在方法最后执行，不管有没有异常都执行&quot;);</div><div>     } </div><div>    //配置环绕通知，相当于自定义通知增强 </div><div>    public Object aroundPrintLog(ProceedingJoinPoint joinPoint){ </div><div>        Object obj = null; </div><div>        try { </div><div>            System.out.println(&quot;在方法之前执行&quot;); </div><div>            obj = joinPoint.proceed();</div><div>            //调用方法，这相当于调用被代理类的被增强的方 法。有点类似，method.invoked()</div><div>             System.out.println(&quot;在方法之后执行，有异常就不执行&quot;);</div><div>        } catch (Throwable throwable) { </div><div>            throwable.printStackTrace(); </div><div>            System.out.println(&quot;在方法抛出异常之后执行&quot;); </div><div>        } finally { </div><div>            System.out.println(&quot;在方法最后执行，不管有没有异常都执行&quot;); </div><div>        } </div><div>        return obj; </div><div>    }    </div><div>}</div></div><div><br/></div><div>基于注解的aop</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">开启注解</span></div><div>&lt;aop:aspectj-autoproxy/&gt;</div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/** * 日志根据类，业务逻辑中的横切逻辑(通知，增强) * @Aspect 注解作用：标记当前类的为日志增强通知切面类 * 作用相当于标签： */ @Component(&quot;logger&quot;) </div><div>@Aspect() </div><div>public class LogUtils { </div><div>    //注解配置切入点表达式，引用只需要调用当前方法即可 </div><div>    @Pointcut(&quot;execution(public * com.hello.service.AccountServiceImpl.* (..))&quot;)</div><div>    public void pointcut(){} </div><div>    //value属性值：可以是切入点表达式，也可以是切入点表达式的引用 </div><div>    //@Before(&quot;pointcut()&quot;) </div><div>    public void beforePrintLog(){</div><div>        //方法之前输出日志</div><div>         System.out.println(&quot;在方法之前执行&quot;); </div><div>    } </div><div>    //@AfterReturning(&quot;pointcut()&quot;) </div><div>    public void afterReturnPrintLog(){</div><div>        //方法之后输出日志 </div><div>        System.out.println(&quot;在方法之后执行，有异常就不执行&quot;); </div><div>    } </div><div>    //@AfterThrowing(&quot;pointcut()&quot;) </div><div>    public void afterThrowingPrintLog(){</div><div>        //方法抛出异常执行</div><div>         System.out.println(&quot;在方法抛出异常之后执行&quot;); </div><div>    } </div><div>    //@After(&quot;pointcut()&quot;) </div><div>    public void afterPrintLog(){</div><div>        //方法的最后执行，不论有没有异常</div><div>         System.out.println(&quot;在方法最后执行，不管有没有异常都执行&quot;);</div><div>     }</div><div>    @Around(&quot;pointcut()&quot;)//配置环绕通知，相当于自定义通知增强 </div><div>    public Object aroundPrintLog(ProceedingJoinPoint joinPoint){ </div><div>        Object obj = null; </div><div>        try { </div><div>            System.out.println(&quot;在方法之前执行&quot;); </div><div>            obj = joinPoint.proceed();</div><div>            //调用方法，这相当于调用被代理类的被增强的方 法。有点类似，method.invoked() </div><div>            System.out.println(&quot;在方法之后执行，有异常就不执行&quot;); </div><div>        } catch (Throwable throwable) { </div><div>            throwable.printStackTrace();</div><div>            System.out.println(&quot;在方法抛出异常之后执行&quot;); </div><div>        } finally {</div><div>             System.out.println(&quot;在方法最后执行，不管有没有异常都执行&quot;);</div><div>        } return obj; </div><div>    } </div><div>}</div></div><div><br/></div><div><span style="font-weight: bold;">循环依赖：多个Bean之间的相互引用</span></div><div><span style="font-weight: bold;">Spring解决循环依赖</span></div><div>Spring采用三级缓存的设计，来解决单例模式下的属性循环依赖问题</div><div>注意：解决的只是单例模式下的set属性赋值的循环依赖问题，对于多例bean的和构造方法注入的方式，并不能通过三级缓存设计解决</div><div>对于多例的问题：因为每个getBean都会创建新的对象，并不能存入缓存，所以不能解决循环依赖</div><div>对于构造方法注入：因为会在实例化的时候才调用</div><div><br/></div><div>对于设计三级缓存，二级缓存也是可以解决循环依赖</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>//修改三级缓存源码，不使用三级缓存</div><div>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#addSingletonFactory()</div><div>protected void addSingletonFactory(String beanName, ObjectFactory&lt;?&gt; singletonFactory) {</div><div>    Assert.notNull(singletonFactory, &quot;Singleton factory must not be null&quot;);</div><div>    synchronized (this.singletonObjects) {</div><div>        // 判断一级缓存中不存在此对象</div><div>        if (!this.singletonObjects.containsKey(beanName)) {</div><div>            // 直接从工厂中获取 Bean</div><div>            Object o = singletonFactory.getObject();</div><div>            // 不存入三级缓存，直接进入二级</div><div>            // 添加至二级缓存中</div><div>            this.earlySingletonObjects.put(beanName, o);</div><div>            this.registeredSingletons.add(beanName);</div><div>        }</div><div>    }</div><div>}</div></div><div><br/></div><div>使用三级缓存而不使用二级缓存，是因为在二级缓存，AOP注入到其他Bean的时候，不是最终的代理对象，而是原始对象</div><div>AbstractAutowireCapableBeanFactory#getEarlyBeanReference()</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) { </div><div>    //循环所有Bean后置处理器 </div><div>    for (BeanPostProcessor bp : getBeanPostProcessors()) { </div><div>        if (bp instanceof SmartInstantiationAwareBeanPostProcessor) { </div><div>            SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp; </div><div>            //开始创建AOP代理【重点】 </div><div>            exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName); </div><div>        } </div><div>    } </div><div>}</div><div><br/></div><div>//获取AOP代理对象的执行流程</div><div>AbstractAutowireCapableBeanFactory#getEarlyBeanReference() </div><div>    AbstractAutoProxyCreator#getEarlyBeanReference()//获取代理对象 </div><div>    AbstractAutoProxyCreator#wrapIfNecessary()//获取代理对象 </div><div>    AbstractAutoProxyCreator#createProxy()//创建代理对象 </div><div>        ProxyCreatorSupport#createAopProxy()//创建Aop对应的代理对象创建工厂 </div><div>            DefaultAopProxyFactory#createAopProxy()//创建Aop代理对象 </div><div>                return new JdkDynamicAopProxy(config);//创建JDK的动态代理封装对 象 </div><div>        ProxyFactory#getProxy()//获取代理对象 </div><div>            JdkDynamicAopProxy#getProxy() </div><div>                Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);//JDK动态代理 </div><div>            CglibAopProxy#getProxy() </div><div>                enhancer.create(constructorArgTypes, constructorArgs);//cglib动态代理</div></div><div><br/></div><ul><li><div>如果不调用后置处理器，返回的Bean和三级缓存一样，都是实例化、普通的Bean</div></li><li><div>如果调用后置，返回的就是代理对象，不是普通的Bean了</div></li><li><div>其实；这就是三级缓存设计的巧妙之处</div></li></ul><div><br/></div></div><div><br/></div></span>
</div></body></html> 